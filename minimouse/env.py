import math, time, random, threading
import numpy as np

import ipywidgets as widgets
from IPython.display import display

from ipycanvas import Canvas, hold_canvas

import ipywidgets as widgets
from IPython.display import display, Javascript




class MicromouseEnv:
    """Simulation environment for a differential-drive micromouse robot.

    The robot navigates a 2-D occupancy grid maze using laser range sensors
    and differential-drive wheel commands.  The environment follows a
    ``reset`` / ``step`` loop similar to OpenAI-Gym style interfaces.

    Parameters
    ----------
    occ : array-like
        2-D occupancy grid (H × W) where 1 = wall, 0 = free space.
        Typically generated by :func:`minimouse.maze.generate_perfect_maze`.
    start_cell : tuple of int
        ``(cx, cy)`` logical cell indices for the robot start position.
    goal_cell : tuple of int
        ``(cx, cy)`` logical cell indices for the goal position.
    cell_size : float, optional
        Side length of a single cell in world units (default ``1.0``).
    n_rays : int, optional
        Number of laser rays spread over a 180° frontal arc (default ``12``).

    Attributes
    ----------
    occ : np.ndarray
        Occupancy grid stored as ``uint8``.
    H, W : int
        Height and width of the occupancy grid (rows, columns).
    x, y, theta : float
        Current robot pose in world coordinates.
    trajectory : list of tuple
        History of ``(x, y)`` positions visited during the current episode.
    waypoints : list or None
        Optional planned waypoints set by an external planner/controller.
    """

    def __init__(self, occ, start_cell, goal_cell, cell_size=1.0, n_rays=12):
        self.occ = np.array(occ, dtype=np.uint8)
        self.cell_size = float(cell_size)
        self.n_rays = int(n_rays)

        self.H, self.W = self.occ.shape

        # robot params
        self.radius = 0.18 * self.cell_size
        self.wheel_base = 0.35 * self.cell_size
        self.dt = 0.05

        # laser params
        self.max_range = 8.0 * self.cell_size

        self.start_cell = start_cell
        self.goal_cell = goal_cell

        self.trajectory = []
        self.waypoints=None
        self.last_action = (0.0, 0.0)

        self.reset()

    def _cell_center_world(self, cx, cy):
        """Convert logical cell indices to world coordinates of the cell centre.

        Parameters
        ----------
        cx, cy : int
            Logical cell column and row indices.

        Returns
        -------
        tuple of float
            ``(world_x, world_y)`` at the centre of the cell.
        """
        # cell centers correspond to occ coords (2*cx+1, 2*cy+1)
        ox = (2*cx + 1) * self.cell_size + 0.5*self.cell_size
        oy = (2*cy + 1) * self.cell_size + 0.5*self.cell_size
        return ox, oy

    def reset(self):
        """Reset the robot to the start cell and return the initial observation.

        Returns
        -------
        dict
            Observation dictionary with keys ``"pose"``, ``"laser"``, and
            ``"goal_cell"`` (see :meth:`_get_obs`).
        """
        sx, sy = self.start_cell
        self.x, self.y = self._cell_center_world(sx, sy)
        self.theta = 0.0
        self.last_action = (0.0, 0.0)
        self.trajectory = [(self.x, self.y)]
        return self._get_obs()

    def step(self, action):
        """Advance the simulation by one time-step.

        Parameters
        ----------
        action : tuple of float
            ``(vl, vr)`` – left and right wheel velocities.

        Returns
        -------
        obs : dict
            Observation after the step (see :meth:`_get_obs`).
        reward : float
            ``1.0`` when the robot reaches the goal, ``0.0`` otherwise.
        done : bool
            ``True`` if the robot is within the goal tolerance.
        info : dict
            ``{"done_reason": "goal"}`` when done, otherwise
            ``{"done_reason": None}``.
        """
        vl, vr = float(action[0]), float(action[1])
        self.last_action = (vl, vr)

        v = 0.5 * (vr + vl)
        w = (vr - vl) / self.wheel_base

        nx = self.x + v * math.cos(self.theta) * self.dt
        ny = self.y + v * math.sin(self.theta) * self.dt
        ntheta = self.theta + w * self.dt

        nx, ny = self._handle_collision(self.x, self.y, nx, ny)

        self.x, self.y, self.theta = nx, ny, ntheta
        self.trajectory.append((self.x, self.y))

        obs = self._get_obs()

        gx, gy = self._cell_center_world(*self.goal_cell)
        done = ((self.x-gx)**2 + (self.y-gy)**2) <= (0.45*self.cell_size)**2
        reward = 1.0 if done else 0.0
        info = {"done_reason": "goal" if done else None}
        return obs, reward, done, info

    def _get_obs(self):
        """Build the current observation dictionary.

        Returns
        -------
        dict
            ``"pose"``  – ``np.float32`` array ``[x, y, theta]``.
            ``"laser"`` – ``np.float32`` array of ``n_rays`` range readings.
            ``"goal_cell"`` – ``np.int32`` array ``[goal_cx, goal_cy]``.
        """
        return {
            "pose": np.array([self.x, self.y, self.theta], dtype=np.float32),
            "laser": self._laser_scan().astype(np.float32),
            "goal_cell": np.array(self.goal_cell, dtype=np.int32),
        }

    def _laser_scan(self):
        """Simulate a frontal 180° laser scan.

        Returns
        -------
        np.ndarray
            Array of shape ``(n_rays,)`` with range distances (``float32``).
        """
        angles = np.linspace(-math.pi/2, math.pi/2, self.n_rays)
        dists = np.empty(self.n_rays, dtype=np.float32)
        for i, a in enumerate(angles):
            dists[i] = self._ray_cast(self.theta + a)
        return dists

    def _ray_cast(self, ang):
        """Cast a single ray at *ang* (world-frame) and return the hit distance.

        Parameters
        ----------
        ang : float
            Ray direction in radians (world frame).

        Returns
        -------
        float
            Distance to the first wall hit, clamped to ``max_range``.
        """
        step = 0.05 * self.cell_size
        for r in np.arange(0.0, self.max_range + 1e-9, step):
            px = self.x + r * math.cos(ang)
            py = self.y + r * math.sin(ang)
            if self._is_wall(px, py):
                return r
        return self.max_range

    def _is_wall(self, x, y):
        """Return ``True`` if world position ``(x, y)`` is inside a wall or out of bounds."""
        ix = int(x / self.cell_size)
        iy = int(y / self.cell_size)
        if ix < 0 or iy < 0 or ix >= self.W or iy >= self.H:
            return True
        return self.occ[iy, ix] == 1

    def _handle_collision(self, x, y, nx, ny):
        """Resolve collisions with axis-aligned sliding.

        If the proposed position ``(nx, ny)`` is inside a wall, the method
        tries each axis independently and falls back to the original position.

        Parameters
        ----------
        x, y : float
            Current (valid) position.
        nx, ny : float
            Proposed new position.

        Returns
        -------
        tuple of float
            Corrected ``(x, y)`` position.
        """
        if not self._is_wall(nx, ny):
            return nx, ny
        if not self._is_wall(nx, y):
            return nx, y
        if not self._is_wall(x, ny):
            return x, ny
        return x, y

    def predict_lookahead(self, steps=18):
        """Predict future positions by forward-simulating the last action.

        The robot state is *not* modified.

        Parameters
        ----------
        steps : int, optional
            Number of time-steps to simulate (default ``18``).

        Returns
        -------
        list of tuple
            ``[(x0, y0), (x1, y1), ...]`` predicted trajectory including
            the current position.
        """
        vl, vr = self.last_action
        x, y, th = self.x, self.y, self.theta
        pts = [(x, y)]
        for _ in range(int(steps)):
            v = 0.5 * (vr + vl)
            w = (vr - vl) / self.wheel_base
            nx = x + v * math.cos(th) * self.dt
            ny = y + v * math.sin(th) * self.dt
            nth = th + w * self.dt
            nx, ny = self._handle_collision(x, y, nx, ny)
            x, y, th = nx, ny, nth
            pts.append((x, y))
        return pts
